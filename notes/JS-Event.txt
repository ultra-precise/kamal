cross-browsers issues 
solution: jQuery

========================================================================
Traditional Event Regeistration Model ==>


To remove the event handler, simply make the onclick method empty:

element.onclick = null;

--------
The event handler is also a normal JavaScript function. It can be executed without an event taking place. If you do

element.onclick()


doSomething() is executed. There’s no real event to go with it, though, so if your function expects one it doesn’t know what to do and produces errors. Therefore this way of executing event handlers is rarely useful.

============================
Solution: 

Multiple event handlers on single event using Traditional even handler properties:


A distinct drawback of the traditional model is that the onclick property can contain only one function. This becomes a problem when you want to register multiple event handlers for one event.

For instance, suppose you’ve written a module that makes it possible to drag and drop a layer. The module registers an onclick event handler to an element so that clicking on it starts the drag and drop. You have also written a module that silently keep track of user clicks and sends this information to the server onunload, so you can find out how your pages are used. This module, too, registers an onclick event handler to an element.

So what you’d really like to do is

element.onclick = startDragDrop;
element.onclick = spyOnUser;
However, it’s here that things start to go wrong. The second registration of a function to onclick overwrites the first one so that only spyOnUser() is executed when the user clicks on the element.

The solution is of course to register a function that executes both other functions:

element.onclick = function () {startDragDrop(); spyOnUser()}

=============
===================================
Event_CurrentTarget_This =>


https://www.quirksmode.org/js/events_order.html

(Web developers need this information.)

"currentTarget" property and "this" keyword :


As we’ve seen earlier, an event has a target or srcElement that contains a reference to the element the event happened on. In our example this is element2, since the user clicked on it.

It is very important to understand that during the capturing and bubbling phases (if any) this target does not change: it always remains a reference to element2.


----------------------------------------------------------------

element1.onclick = doSomething;
element2.onclick = doSomething;
If the user clicks on element2 doSomething() is executed twice. But how do you know which HTML element is currently handling the event? target/srcElement don’t give a clue, they always refer to element2 since it is the original source of the event.

To solve this problem W3C has added the currentTarget property. It contains a reference to the HTML element the event is currently being handled by: exactly what we need. Unfortunately the Microsoft model doesn’t contain a similar property.

You can also use the "this" keyword. In the example above it refers to the HTML element the event is handled on, just like currentTarget.



======================================================
Problems of the Microsoft model :


But when you use the Microsoft event registration model the "this" keyword doesn’t refer to the HTML element. Combined with the lack of a currentTarget–like property in the Microsoft model, this means that if you do

element1.attachEvent('onclick',doSomething)
element2.attachEvent('onclick',doSomething)
you cannot know which HTML element currently handles the event. This is the most serious problem with the Microsoft event registration model and for me it’s reason enough never to use it, not even in IE/Win only applications.

I hope Microsoft will soon add a currentTarget–like property — or maybe even follow the standard? Web developers need this information.

===============================
===================================================
Event_Accessing =>

element.onclick = doSomething;

function doSomething(e) {
	if (!e) var e = window.event;
	// e gives access to the event in all browsers
}



==============================================================
W3C/Netscape Browsers -->


element.onclick = doSomething;

function doSomething(e) {
	// e gives access to the event
alert('Event type is ' + e.type)
}


element.onclick = function (e) {alert('Event type is ' + e.type)}


================================================================
Microsoft Browsers -->

element.onclick = doSomething;

function doSomething() {
	// window.event gives access to the event
alert('Event type is ' + window.event.type)
}


element.onclick = function () {alert('Event type is ' + window.event.type)}


===============================================================



